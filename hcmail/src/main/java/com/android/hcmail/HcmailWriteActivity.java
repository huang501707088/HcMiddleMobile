package com.android.hcmail;import android.app.Activity;import android.content.ContentResolver;import android.content.ContentUris;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import android.provider.OpenableColumns;import android.text.TextUtils;import android.util.Log;import android.view.Gravity;import android.view.KeyEvent;import android.view.View;import android.view.inputmethod.InputMethodManager;import android.webkit.WebView;import android.widget.EditText;import android.widget.ImageView;import android.widget.ListView;import android.widget.MultiAutoCompleteTextView;import android.widget.TextView;import com.android.common.contacts.DataUsageStatUpdater;import com.android.email.Controller;import com.android.email.Email;import com.android.email.mail.internet.EmailHtmlUtil;import com.android.emailcommon.Logging;import com.android.emailcommon.mail.Address;import com.android.emailcommon.provider.Account;import com.android.emailcommon.provider.EmailContent;import com.android.emailcommon.provider.Mailbox;import com.android.emailcommon.utility.AttachmentUtilities;import com.android.emailcommon.utility.EmailAsyncTask;import com.android.emailcommon.utility.Utility;import com.android.ex.chips.ChipsUtil;import com.android.ex.chips.RecipientEditTextView;import com.android.hcframe.HcBaseActivity;import com.android.hcframe.HcLog;import com.android.hcframe.HcUtil;import com.android.hcframe.TopBarView;import com.android.hcframe.email.R;import com.android.email.activity.AddressTextView;import com.android.hcframe.sql.OperateDatabase;import com.android.hcframe.sql.SettingHelper;import com.android.hcframe.view.selector.HcChooseHomeView;import com.android.hcframe.view.selector.ItemInfo;import com.android.hcframe.view.selector.file.image.ImageChooseActivity;import com.android.hcframe.view.selector.file.image.ImageItemInfo;import java.io.File;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ExecutionException;/** * Created by zhujiabin on 2017/3/20. */public class HcmailWriteActivity extends HcBaseActivity implements View.OnClickListener, View.OnKeyListener, HcmailAttaAdapter.OnDeleCallback {    private TopBarView mWriteTopBar;    private MultiAutoCompleteTextView mWriteTo;    private MultiAutoCompleteTextView mWriteCc;    private EditText mWriteSubject;    private EditText mWriteBodyText;    private ImageView mWriteAddAttachment;    private TextView mWriteSave;    private TextView mWriteSend;    private WebView mWriteWeb;    private ListView mAttaContainer;    /**     * The source message for a reply, reply all, or forward. This is asynchronously loaded.     */    private EmailContent.Message mSource;    /**     * A collection of attachments the user is currently wanting to attach to this message.     */    private final ArrayList<EmailContent.Attachment> mAttachments = new ArrayList<EmailContent.Attachment>();    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();    /**     * The attachments associated with the source attachments. Usually included in a forward.     */    private ArrayList<EmailContent.Attachment> mSourceAttachments = new ArrayList<EmailContent.Attachment>();    private static String getPackedAddresses(TextView view) {        Address[] addresses = Address.parse(view.getText().toString().trim());        return Address.pack(addresses);    }    /**     * A registry of the active tasks used to save messages.     */    private static final ConcurrentHashMap<Long, SendOrSaveMessageTask> sActiveSaveTasks =            new ConcurrentHashMap<Long, SendOrSaveMessageTask>();    private EmailContent.Message mDraft = new EmailContent.Message();    private Controller mController;    /**     * The ID of the latest save or send task requested by this Activity.     */    private long mLastSaveTaskId = -1;    private static long sNextSaveTaskId = 1;    private static final int ACTIVITY_REQUEST_PICK_ATTACHMENT = 1;    private Account mAccount;//setAccount    private static final String EXTRA_ACCOUNT_ID = "account_id";    private static final String EXTRA_MESSAGE_ID = "message_id";    /**     * The action being handled by this activity. This is initially populated from the     * {@link Intent}, but can switch between reply/reply all/forward where appropriate.     * This value is nullable (a null value indicating a regular "compose").     */    private String mAction;    /**     * Action     */    public static final String ACTION_FORWARD = "com.android.hcemail.intent.action.FORWARD";    public static final String ACTION_REPLY_TO = "com.android.hcemail.intent.action.REPLY_TO";    public static final String ACTION_OUT_BOX = "com.android.hcemail.intent.action.OUTBOX";    public static final String ACTION_SEND_BOX = "com.android.hcemail.intent.action.SEND";    public static final String ACTION_DRAFTS_BOX = "com.android.hcemail.intent.action.DRAFTS";    public static final String ACTION_CONTACT = "com.android.hcemail.intent.action.CONTACT";    /**     * 全局变量     */    private String mId;    private String mSubject;    private String mSend;    private String mTo;    private String mCc;    private String fFri;    private String fAdd;    private ImageView mToImg;    private ImageView mCcImg;    /**     * listview下的线     */    private View mLine;    /**     * 自定义的底部弹出框类     */    private SelectPicPopupWindow menuWindow;    /**     * 联系人     */    public static final int LOCATION_LOCAL = 0;    /**     * APP中的通讯录     */    public static final int LOCATION_APP = 1;    /**     * 存储邮件地址     */    private ArrayList<String> mInfo = new ArrayList<String>();    private ArrayList<String> mAddInfo = new ArrayList<String>();    private boolean mToFlag = false;    private boolean mCcFlag = false;    private boolean mDeleToFlag = false;    private boolean mDeleCcFlag = false;    /**     * 添加附件     */    private static final int MAX_COUNT = 9;    private int mMaxCount = MAX_COUNT;    private List<HcmailAtta> mImages = new ArrayList<HcmailAtta>();    private HcmailAttaAdapter mAdapter;    private static final String[] ATTACHMENT_META_SIZE_PROJECTION = {            OpenableColumns.SIZE    };    private static final int ATTACHMENT_META_SIZE_COLUMN_SIZE = 0;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.hcmail_message_compose);        initView();        initData();        initEvent();    }    private void initView() {        mWriteTopBar = (TopBarView) findViewById(R.id.hcmail_write_top_bar);        mWriteTo = (AddressTextView) findViewById(R.id.to);        mWriteCc = (AddressTextView) findViewById(R.id.cc);        mWriteSubject = (EditText) findViewById(R.id.subject);        mWriteBodyText = (EditText) findViewById(R.id.body_text);        mWriteSave = (TextView) findViewById(R.id.save);        mAttaContainer = (ListView) findViewById(R.id.attachment_container_list);        mWriteAddAttachment = (ImageView) findViewById(R.id.add_attachment);        mWriteSend = (TextView) findViewById(R.id.send);        mToImg = (ImageView) findViewById(R.id.hcmail_to_img);        mCcImg = (ImageView) findViewById(R.id.hcmail_cc_img);        mWriteWeb = (WebView) findViewById(R.id.web_view_text);        mLine = findViewById(R.id.hcmail_line);    }    private void initData() {        mWriteTopBar.setTitle("写邮件");        mWriteTopBar.setLeftBtnVisiable(View.VISIBLE);        mWriteTopBar.setMenuSrc(R.drawable.hcmail_back);        mWriteTopBar.setLeftViewListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                //退出该activity                finish();            }        });        mController = Controller.getInstance(this);        Intent intent = getIntent();        setAction(intent.getAction());        HcLog.D("intent.getAction()=" + intent.getAction());        resolveIntent(intent);        String sign = HcEmailSharedHelper.getSign(this);        if (!"".equals(sign) && sign != null) {            HcLog.D("sign = " + sign);            mWriteBodyText.setText("\n\n\n" + sign);        } else {            mWriteBodyText.setSelection(mWriteBodyText.getText().length());        }        //添加附件        mAdapter = new HcmailAttaAdapter(HcmailWriteActivity.this, mImages, true);        mAttaContainer.setAdapter(mAdapter);    }    private void resolveIntent(Intent intent) {        setAccount(intent);        setInitialComposeText(null, getAccountSignature(mAccount));        HcLog.D("getAccountSignature(mAccount) =" + getAccountSignature(mAccount));//        setMessageLoaded(true);    }    /**     * Set a message body and a signature when the Activity is launched.     *     * @param text the message body     *///    @VisibleForTesting    void setInitialComposeText(CharSequence text, String signature) {        mWriteBodyText.setText("");        int textLength = 0;        if (text != null) {            mWriteBodyText.append(text);            textLength = text.length();        }        if (!TextUtils.isEmpty(signature)) {            if (textLength == 0 || text.charAt(textLength - 1) != '\n') {                mWriteBodyText.append("\n");            }            mWriteBodyText.append(signature);            // Reset cursor to right before the signature.            mWriteBodyText.setSelection(textLength);        }    }    /**     * @return the signature for the specified account, if non-null. If the account specified is     * null or has no signature, {@code null} is returned.     */    private static String getAccountSignature(Account account) {        return (account == null) ? null : account.mSignature;    }    private void setAction(String action) {        if (HcUtil.equal(action, mAction)) {            return;        }        mAction = action;        Intent intent = getIntent();        if (intent != null) {            if (ACTION_OUT_BOX.equals(mAction)) {                //发件箱进入编辑                HcmailBox outBox = intent.getParcelableExtra("HcmailOutbox");                mId = outBox.getBoxId();                mSubject = outBox.getBoxTitle();                mWriteSubject.setText(mSubject);                //通过id获取邮件内容            } else if (isForward()) {                //点击转发按钮进入编辑                mId = intent.getStringExtra("messageId");                mSubject = intent.getStringExtra("subject");                mWriteSubject.setText(mSubject);                mWriteWeb.setVisibility(View.VISIBLE);                loadSourceMessage(Long.valueOf(mId), true);            } else {                if (ACTION_REPLY_TO.equals(mAction)) {                    mWriteWeb.setVisibility(View.VISIBLE);                    mWriteTo.setVisibility(View.VISIBLE);                    mId = intent.getStringExtra("messageId");                    mTo = intent.getStringExtra("mTo");                    mCc = intent.getStringExtra("mCc");                    fFri = intent.getStringExtra("fFri");                    fAdd = intent.getStringExtra("fAdd");                    String messageTo = intent.getStringExtra("messageTo");                    String messageCc = intent.getStringExtra("messageCc");                    StringBuilder builder = new StringBuilder();                    String[] mTos = null, messageTos = null;                    if (mTo != null && messageTo != null) {                        mTos = mTo.split(",");                        messageTos = messageTo.split(",");                    }                    String email = OperateDatabase.getMailBoxName(this, SettingHelper.getUserId(this));                    if (email == null) {                        email = SettingHelper.getEmail(this);                    }                    //发件人                    if (!fAdd.contains(email)) {                        builder.append(fFri);                        builder.append("<");                        builder.append(fAdd);                        mInfo.add(fAdd);                        builder.append(">");                        builder.append(",");                    }                    //收件人                    if (mTo != null && messageTo != null) {                        for (int i = 0; i < mTos.length; i++) {                            HcLog.D("messageTos[i] = " + messageTos[i] + "email =" + email);                            StringBuilder sb = new StringBuilder();                            if (!messageTos[i].contains(email)) {                                //此处要区分没有"<"的情况,zhaobq@zjhcsoft.com                                if (messageTos[i].indexOf("<") != -1) {                                    String[] message = messageTos[i].split("<");                                    sb.append(mTos[i]);                                    sb.append("<");                                    sb.append(message[1]);                                    mInfo.add(message[1].substring(0, message[1].length() - 1));                                    builder.append(sb.toString());                                    builder.append(",");                                } else {                                    sb.append(mTos[i]);                                    sb.append("<");                                    sb.append(messageTos[i]);                                    mInfo.add(messageTos[i].substring(0, messageTos[i].length() - 1));                                    builder.append(sb.toString());                                    builder.append(",");                                }                            } else {                                continue;                            }                        }                    }                    //抄送人                    if (mCc != null && messageCc != null) {                        String[] mCcs = mCc.split(",");                        String[] messageCcs = messageCc.split(",");                        for (int i = 0; i < mCcs.length; i++) {                            StringBuilder sb = new StringBuilder();                            if (!messageCcs[i].contains(email)) {                                if (messageCcs[i].indexOf("<") != -1) {                                    String[] message = messageCcs[i].split("<");                                    sb.append(mCcs[i]);                                    sb.append("<");                                    sb.append(message[1]);                                    mInfo.add(message[1].substring(0, message[1].length() - 1));                                    builder.append(sb.toString());                                    builder.append(",");                                } else {                                    sb.append(mCcs[i]);                                    sb.append("<");                                    sb.append(messageCcs[i]);                                    mInfo.add(messageCcs[i].substring(0, messageCcs[i].length() - 1));                                    builder.append(sb.toString());                                    builder.append(",");                                }                            } else {                                continue;                            }                        }                    }                    HcLog.D("builder.toString() = " + builder.toString());                    mWriteTo.setText(builder.toString());                    HcLog.D("mTo = " + mTo + ",mCc =" + mCc);                    loadSourceMessage(Long.valueOf(mId), true);                } else if (ACTION_SEND_BOX.equals(mAction)) {                    //发件箱进入编辑                    HcmailBox outBox = intent.getParcelableExtra("HcmailSendbox");                    mId = outBox.getBoxId();                    mSubject = outBox.getBoxTitle();                    mSend = outBox.getBoxName();                    mWriteTo.setText(mSend);                    mWriteSubject.setText(mSubject);                } else if (ACTION_DRAFTS_BOX.equals(mAction)) {                    HcmailBox drafts = intent.getParcelableExtra("HcmailDraftsbox");                    mId = drafts.getBoxId();                    mSubject = drafts.getBoxTitle();                    mSend = drafts.getBoxName();                    mWriteTo.setText(mSend);                    mWriteSubject.setText(mSubject);                    resumeDraft(Long.valueOf(mId), null, true);                } else if (ACTION_CONTACT.equals(mAction)) {                    String mTo = intent.getStringExtra("to");                    mInfo.add(mTo);                    StringBuilder sb = new StringBuilder();                    sb.append(mTo);                    sb.append(",");                    mWriteTo.setText(sb.toString());                }            }        }    }    private void initEvent() {        mWriteAddAttachment.setOnClickListener(this);        mWriteSend.setOnClickListener(this);        mWriteSave.setOnClickListener(this);        mToImg.setOnClickListener(this);        mCcImg.setOnClickListener(this);        mWriteTo.setOnKeyListener(this);        mWriteCc.setOnKeyListener(this);        HcmailAttaAdapter.setOnDeleCallback(this);    }    @Override    public boolean onKeyDown(int keyCode, KeyEvent event) {        return super.onKeyDown(keyCode, event);    }    @Override    protected void onDestroy() {        super.onDestroy();    }    @Override    public void onClick(View v) {        int i = v.getId();        if (i == R.id.add_attachment) {            //点击添加附件按钮            onAddAttachment();        } else if (i == R.id.save) {            //点击存为草稿按钮            saveIfNeeded();            finish();        } else if (i == R.id.send) {            //点击发送按钮            if (!isAddressAllValid()) {                HcUtil.showToast(this, R.string.message_compose_error_invalid_email);            } else if (getAddresses(mWriteTo).length == 0 &&                    getAddresses(mWriteCc).length == 0) {                HcUtil.showToast(this, R.string.message_compose_error_no_recipients);            } else {                sendOrSaveMessage(true);                finish();            }        } else if (i == R.id.hcmail_to_img) {            mToFlag = true;            hideKey();            addAddress();        } else if (i == R.id.hcmail_cc_img) {            mCcFlag = true;            hideKey();            addAddress();        }    }    private void addAddress() {        //点击移动到按钮        menuWindow = new SelectPicPopupWindow(this, itemsOnClick);        //显示窗口        menuWindow.showAtLocation(this.findViewById(R.id.hcmail_write_main), Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, 0, 0); //设置layout在PopupWindow中显示的位置    }    //为弹出窗口实现监听类    private View.OnClickListener itemsOnClick = new View.OnClickListener() {        public void onClick(View v) {            menuWindow.dismiss();            int i = v.getId();            Intent intent = new Intent(HcmailWriteActivity.this, HcmailChooseActivity.class);            intent.putExtra(HcmailChooseActivity.SELECT, true);            if (i == R.id.hcmail_popup_contacts) {                //点击联系人                intent.putExtra("location", LOCATION_LOCAL);            } else/* if (i == R.id.hcmail_popup_address)*/ {                //点击通讯录                intent.putExtra("location", LOCATION_APP);            }            startActivityForResult(intent, HcChooseHomeView.REQUEST_CODE);        }    };    private void hideKey() {        InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);        imm.hideSoftInputFromWindow(this.findViewById(R.id.hcmail_write_main).getWindowToken(), 0); //强制隐藏键盘    }    private void saveIfNeeded() {        sendOrSaveMessage(false);    }    /**     * Send or save a message:     * - out of the UI thread     * - write to Drafts     * - if send, invoke Controller.sendMessage()     * - when operation is complete, display toast     */    private void sendOrSaveMessage(boolean send) {//        if (!mMessageLoaded) {//            Log.w(Logging.LOG_TAG,//                    "Attempted to save draft message prior to the state being fully loaded");//            return;        synchronized (sActiveSaveTasks) {            mLastSaveTaskId = sNextSaveTaskId++;            SendOrSaveMessageTask task = new SendOrSaveMessageTask(mLastSaveTaskId, send);            // Ensure the tasks are executed serially so that rapid scheduling doesn't result            // in inconsistent data.            task.executeSerial();        }    }    /**     * Checks whether all the email addresses listed in TO, CC, BCC are valid.     *///    @VisibleForTesting    boolean isAddressAllValid() {        boolean supportsChips = ChipsUtil.supportsChipsUi();        for (TextView view : new TextView[]{mWriteTo, mWriteCc}) {            String addresses = view.getText().toString().trim();            if (!Address.isAllValid(addresses)) {                // Don't show an error message if we're using chips as the chips have                // their own error state.                if (!supportsChips || !(view instanceof RecipientEditTextView)) {                    HcUtil.showToast(this, R.string.message_compose_error_invalid_email);                }                return false;            }        }        return true;    }    public void setAccount(Intent intent) {        long accountId = intent.getLongExtra(EXTRA_ACCOUNT_ID, -1);        HcLog.D("accountId = " + accountId);        Account account = null;        if (accountId != Account.NO_ACCOUNT) {            // User supplied an account; make sure it exists            account = Account.restoreAccountWithId(this, accountId);            HcLog.D("account1 = " + account);            // Deleted account is no account...            if (account == null) {                accountId = Account.NO_ACCOUNT;            }        }        // If we still have no account, try the default        if (accountId == Account.NO_ACCOUNT) {            accountId = Account.getDefaultAccountId(this);            HcLog.D("accountId2 = " + accountId);            if (accountId != Account.NO_ACCOUNT) {                // Make sure it exists...                account = Account.restoreAccountWithId(this, accountId);                HcLog.D("account2 = " + account);                // Deleted account is no account...                if (account == null) {                    accountId = Account.NO_ACCOUNT;                }            }        }        // If we can't find an account, set one up        if (accountId == Account.NO_ACCOUNT || account == null) {            // There are no accounts set up. This should not have happened. Prompt the            // user to set up an account as an acceptable bailout.//            Welcome.actionStart(this);            finish();        } else {            setAccount(account);        }    }    private void setAccount(Account account) {        if (account == null) {            HcUtil.showToast(this, R.string.widget_no_accounts);            Log.d(Logging.LOG_TAG, "The account has been deleted, force finish it");            finish();        }        mAccount = account;        //没有发送人//        mFromView.setText(account.mEmailAddress);//        mAddressAdapterTo//                .setAccount(new android.accounts.Account(account.mEmailAddress, "unknown"));//        mAddressAdapterCc//                .setAccount(new android.accounts.Account(account.mEmailAddress, "unknown"));    }    @Override    public void onDeleClick(View view, int position, HcmailAtta item) {        mImages.remove(item);        String name = item.getAttaName();        EmailContent.Attachment attachment = null;        for (EmailContent.Attachment atta : mAttachments) {            HcLog.D("atta.mFileName = " + atta.mFileName + ", name = " + name);            if (name.equals(atta.mFileName)) {                attachment = atta;            }        }        deleteAttachment(mAttachments, attachment);        if (mAttachments.size() == 0) {            mLine.setVisibility(View.GONE);        }        mAdapter.notifyDataSetChanged();    }    private class SendOrSaveMessageTask extends EmailAsyncTask<Void, Void, Long> {        private final boolean mSend;        private final long mTaskId;        /**         * A context that will survive even past activity destruction.         */        private final Context mContext;        public SendOrSaveMessageTask(long taskId, boolean send) {            super(null /* DO NOT cancel in onDestroy */);            HcLog.D("$SendOrSaveMessageTask#SendOrSaveMessageTask taskId =" + taskId + " send = " + send);            mTaskId = taskId;            mSend = send;            mContext = getApplicationContext();            sActiveSaveTasks.put(mTaskId, this);        }        @Override        protected Long doInBackground(Void... params) {            HcLog.D("$SendOrSaveMessageTask#SendOrSaveMessageTask params =" + params);            synchronized (mDraft) {                updateMessage(mDraft, mAccount, mAttachments.size() > 0, mSend);                ContentResolver resolver = getContentResolver();                if (mDraft.isSaved()) {                    // Update the message                    Uri draftUri =                            ContentUris.withAppendedId(EmailContent.Message.SYNCED_CONTENT_URI, mDraft.mId);                    resolver.update(draftUri, getUpdateContentValues(mDraft), null, null);                    // Update the body                    ContentValues values = new ContentValues();                    values.put(EmailContent.BodyColumns.TEXT_CONTENT, mDraft.mText);                    values.put(EmailContent.BodyColumns.TEXT_REPLY, mDraft.mTextReply);                    values.put(EmailContent.BodyColumns.HTML_REPLY, mDraft.mHtmlReply);                    values.put(EmailContent.BodyColumns.INTRO_TEXT, mDraft.mIntroText);                    values.put(EmailContent.BodyColumns.SOURCE_MESSAGE_KEY, mDraft.mSourceKey);                    EmailContent.Body.updateBodyWithMessageId(HcmailWriteActivity.this, mDraft.mId, values);                } else {                    // mDraft.mId is set upon return of saveToMailbox()                    mController.saveToMailbox(mDraft, Mailbox.TYPE_DRAFTS);                }                boolean hasUnloadedAttachments = false;                for (EmailContent.Attachment attachment : mAttachments) {                    if (attachment.mContentUri == null &&                            ((attachment.mFlags & EmailContent.Attachment.FLAG_SMART_FORWARD) == 0)) {                        attachment.mFlags |= EmailContent.Attachment.FLAG_DOWNLOAD_FORWARD;                        hasUnloadedAttachments = true;                        if (Email.DEBUG) {                            Log.d(Logging.LOG_TAG,                                    "Requesting download of attachment #" + attachment.mId);                        }                    }                    // Make sure the UI version of the attachment has the now-correct id; we will                    // use the id again when coming back from picking new attachments                    if (!attachment.isSaved()) {                        // this attachment is new so save it to DB.                        attachment.mMessageKey = mDraft.mId;                        attachment.save(HcmailWriteActivity.this);                    } else if (attachment.mMessageKey != mDraft.mId) {                        // We clone the attachment and save it again; otherwise, it will                        // continue to point to the source message.  From this point forward,                        // the attachments will be independent of the original message in the                        // database; however, we still need the message on the server in order                        // to retrieve unloaded attachments                        attachment.mMessageKey = mDraft.mId;                        ContentValues cv = attachment.toContentValues();                        cv.put(EmailContent.Attachment.FLAGS, attachment.mFlags);                        cv.put(EmailContent.Attachment.MESSAGE_KEY, mDraft.mId);                        getContentResolver().insert(EmailContent.Attachment.CONTENT_URI, cv);                    }                }                if (mSend) {                    // Let the user know if message sending might be delayed by background                    // downlading of unloaded attachments                    if (hasUnloadedAttachments) {                        HcUtil.showToast(HcmailWriteActivity.this, R.string.message_view_attachment_background_load);                    }                    HcLog.D("mDraft = " + mDraft);                    mController.sendMessage(mDraft);                    ArrayList<CharSequence> addressTexts = new ArrayList<CharSequence>();                    addressTexts.add(mWriteTo.getText());                    addressTexts.add(mWriteCc.getText());                    DataUsageStatUpdater updater = new DataUsageStatUpdater(mContext);                    updater.updateWithRfc822Address(addressTexts);                }                return mDraft.mId;            }        }    }    private ContentValues getUpdateContentValues(EmailContent.Message message) {        ContentValues values = new ContentValues();        values.put(EmailContent.MessageColumns.TIMESTAMP, message.mTimeStamp);        values.put(EmailContent.MessageColumns.FROM_LIST, message.mFrom);        values.put(EmailContent.MessageColumns.TO_LIST, message.mTo);        values.put(EmailContent.MessageColumns.CC_LIST, message.mCc);        values.put(EmailContent.MessageColumns.SUBJECT, message.mSubject);        values.put(EmailContent.MessageColumns.DISPLAY_NAME, message.mDisplayName);        values.put(EmailContent.MessageColumns.FLAG_READ, message.mFlagRead);        values.put(EmailContent.MessageColumns.FLAG_LOADED, message.mFlagLoaded);        values.put(EmailContent.MessageColumns.FLAG_ATTACHMENT, message.mFlagAttachment);        values.put(EmailContent.MessageColumns.FLAGS, message.mFlags);        return values;    }    /**     * Updates the given message using values from the compose UI.     *     * @param message        The message to be updated.     * @param account        the account (used to obtain From: address).     * @param hasAttachments true if it has one or more attachment.     * @param sending        set true if the message is about to sent, in which case we perform final     *                       clean up;     */    private void updateMessage(EmailContent.Message message, Account account, boolean hasAttachments,                               boolean sending) {        if (message.mMessageId == null || message.mMessageId.length() == 0) {            message.mMessageId = Utility.generateMessageId();        }        message.mTimeStamp = System.currentTimeMillis();        message.mFrom = new Address(account.getEmailAddress(), account.getSenderName()).pack();        message.mTo = getPackedAddresses(mWriteTo);        message.mCc = getPackedAddresses(mWriteCc);        message.mSubject = mWriteSubject.getText().toString();        message.mText = mWriteBodyText.getText().toString();        message.mAccountKey = account.mId;        message.mDisplayName = makeDisplayName(message.mTo, message.mCc);        message.mFlagRead = true;        message.mFlagLoaded = EmailContent.Message.FLAG_LOADED_COMPLETE;        message.mFlagAttachment = hasAttachments;        // Use the Intent to set flags saying this message is a reply or a forward and save the        // unique id of the source message        if (mSource != null) {            message.mSourceKey = mSource.mId;            // If the quote bar is visible; this must either be a reply or forward            // Get the body of the source message here            message.mHtmlReply = mSource.mHtml;            message.mTextReply = mSource.mText;            String fromAsString = Address.unpackToString(mSource.mFrom);            if (isForward()) {                message.mFlags |= EmailContent.Message.FLAG_TYPE_FORWARD;                String subject = mSource.mSubject;                String to = Address.unpackToString(mSource.mTo);                String cc = Address.unpackToString(mSource.mCc);                message.mIntroText =                        getString(R.string.message_compose_fwd_header_fmt, subject, fromAsString,                                to != null ? to : "", cc != null ? cc : "");                message.mFlags &= ~EmailContent.Message.FLAG_NOT_INCLUDE_QUOTED_TEXT;            } else {                message.mFlags |= EmailContent.Message.FLAG_TYPE_REPLY;                message.mIntroText =                        getString(R.string.message_compose_reply_header_fmt, fromAsString);            }        }    }    /*   * Computes a short string indicating the destination of the message based on To, Cc, Bcc.   * If only one address appears, returns the friendly form of that address.   * Otherwise returns the friendly form of the first address appended with "and N others".   */    private String makeDisplayName(String packedTo, String packedCc) {        Address first = null;        int nRecipients = 0;        for (String packed : new String[]{packedTo, packedCc}) {            Address[] addresses = Address.unpack(packed);            nRecipients += addresses.length;            if (first == null && addresses.length > 0) {                first = addresses[0];            }        }        if (nRecipients == 0) {            return "";        }        String friendly = first.toFriendly();        if (nRecipients == 1) {            return friendly;        }        return this.getString(R.string.message_compose_display_name, friendly, nRecipients - 1);    }    private boolean isForward() {        return ACTION_FORWARD.equals(mAction);    }    private static Address[] getAddresses(TextView view) {        Address[] addresses = Address.parse(view.getText().toString().trim());        return addresses;    }    private void addAttachment(EmailContent.Attachment attachment) {        // Before attaching the attachment, make sure it meets any other pre-attach criteria        HcLog.D("attachment.mSize = " + attachment.mSize);//        if (attachment.mSize > AttachmentUtilities.MAX_ATTACHMENT_UPLOAD_SIZE) {//            HcUtil.showToast(HcmailWriteActivity.this, R.string.message_compose_attachment_size);//            return;//        }        mAttachments.add(attachment);//        updateAttachmentUi();    }    /**     * Kick off a picker for whatever kind of MIME types we'll accept and let Android take over.     */    private void onAddAttachment() {        //添加附件        startImageChooseActivity();    }    private void startImageChooseActivity() {        int offset = mMaxCount - mImages.size() + 1; // 第一项要去除        if (offset <= 0) {            HcUtil.showToast(this, "图片已达到最大张数!");            return;        }        Intent intent = new Intent(this, ImageChooseActivity.class);        intent.putExtra(ImageChooseActivity.SELECT_COUNT, offset);        startActivityForResult(intent, HcUtil.REQUEST_CODE_FROM_CAMERA);    }    /**     * Asynchronously loads a draft message for editing.     * This may or may not restore the view contents, depending on whether or not callers want,     * since in the case of screen rotation, those are restored automatically.     */    private void resumeDraft(            long draftId,            SendOrSaveMessageTask existingSaveTask,            final boolean restoreViews) {        // Note - this can be Message.NOT_SAVED if there is an existing save task in progress        // for the draft we need to load.        mDraft.mId = draftId;        new LoadMessageTask(draftId, existingSaveTask, new OnMessageLoadHandler() {            public void onMessageLoaded(EmailContent.Message message, EmailContent.Body body) {                message.mHtml = body.mHtmlContent;                message.mText = body.mTextContent;                message.mHtmlReply = body.mHtmlReply;                message.mTextReply = body.mTextReply;                message.mIntroText = body.mIntroText;                message.mSourceKey = body.mSourceKey;                mDraft = message;                mWriteBodyText.setText(message.mText);                HcLog.D("message.mHtml = " + message.mHtml + ", message.mText = " + message.mText + "," +                        "message.mHtmlReply = " + message.mHtmlReply + ",message.mTextReply = " + message.mTextReply                        + ",message.mIntroText = " + message.mIntroText + "message.mSourceKey = " + message.mSourceKey);                // Load attachments related to the draft.                loadAttachments(message.mId, mAccount, new AttachmentLoadedCallback() {                    @Override                    public void onAttachmentLoaded(EmailContent.Attachment[] attachments) {                        for (EmailContent.Attachment attachment : attachments) {                            addAttachment(attachment);                            //显示附件                        }                    }                });            }            @Override            public void onLoadFailed() {                HcUtil.showToast(HcmailWriteActivity.this, R.string.error_loading_message_body);                finish();            }        }).executeSerial((Void[]) null);    }    private interface AttachmentLoadedCallback {        /**         * Handles completion of the loading of a set of attachments.         * Callback will always happen on the main thread.         */        void onAttachmentLoaded(EmailContent.Attachment[] attachment);    }    private interface OnMessageLoadHandler {        /**         * Handles a load to a message (e.g. a draft message or a source message).         */        void onMessageLoaded(EmailContent.Message message, EmailContent.Body body);        /**         * Handles a failure to load a message.         */        void onLoadFailed();    }    /**     * Asynchronously loads a message and the account information.     * This can be used to load a reference message (when replying) or when restoring a draft.     */    private class LoadMessageTask extends EmailAsyncTask<Void, Void, Object[]> {        /**         * The message ID to load, if available.         */        private long mMessageId;        /**         * A future-like reference to the save task which must complete prior to this load.         */        private final SendOrSaveMessageTask mSaveTask;        /**         * A callback to pass the results of the load to.         */        private final OnMessageLoadHandler mCallback;        public LoadMessageTask(                long messageId, SendOrSaveMessageTask saveTask, OnMessageLoadHandler callback) {            super(mTaskTracker);            mMessageId = messageId;            mSaveTask = saveTask;            mCallback = callback;        }        private long getIdToLoad() throws InterruptedException, ExecutionException {            if (mMessageId == -1) {                mMessageId = mSaveTask.get();            }            return mMessageId;        }        @Override        protected Object[] doInBackground(Void... params) {            long messageId;            try {                messageId = getIdToLoad();            } catch (InterruptedException e) {                // Don't have a good message ID to load - bail.                Log.e(Logging.LOG_TAG,                        "Unable to load draft message since existing save task failed: " + e);                return null;            } catch (ExecutionException e) {                // Don't have a good message ID to load - bail.                Log.e(Logging.LOG_TAG,                        "Unable to load draft message since existing save task failed: " + e);                return null;            }            EmailContent.Message message = EmailContent.Message.restoreMessageWithId(HcmailWriteActivity.this, messageId);            if (message == null) {                return null;            }            long accountId = message.mAccountKey;            Account account = Account.restoreAccountWithId(HcmailWriteActivity.this, accountId);            EmailContent.Body body;            try {                body = EmailContent.Body.restoreBodyWithMessageId(HcmailWriteActivity.this, message.mId);            } catch (RuntimeException e) {                Log.d(Logging.LOG_TAG, "Exception while loading message body: " + e);                return null;            }            return new Object[]{message, body, account};        }        @Override        protected void onSuccess(Object[] results) {            if ((results == null) || (results.length != 3)) {                mCallback.onLoadFailed();                return;            }            final EmailContent.Message message = (EmailContent.Message) results[0];            final EmailContent.Body body = (EmailContent.Body) results[1];            final Account account = (Account) results[2];            if ((message == null) || (body == null) || (account == null)) {                mCallback.onLoadFailed();                return;            }            setAccount(account);            mCallback.onMessageLoaded(message, body);        }    }    private void loadAttachments(            final long messageId,            final Account account,            final AttachmentLoadedCallback callback) {        new EmailAsyncTask<Void, Void, EmailContent.Attachment[]>(mTaskTracker) {            @Override            protected EmailContent.Attachment[] doInBackground(Void... params) {                return EmailContent.Attachment.restoreAttachmentsWithMessageId(HcmailWriteActivity.this, messageId);            }            @Override            protected void onSuccess(EmailContent.Attachment[] attachments) {                if (attachments == null) {                    attachments = new EmailContent.Attachment[0];                }                callback.onAttachmentLoaded(attachments);            }        }.executeSerial((Void[]) null);    }    /**     * Asynchronously loads a source message (to be replied or forwarded in this current view),     * populating text fields and quoted text fields when the load finishes, if requested.     */    private void loadSourceMessage(long sourceMessageId, final boolean restoreViews) {        new LoadMessageTask(sourceMessageId, null, new OnMessageLoadHandler() {            @Override            public void onMessageLoaded(EmailContent.Message message, EmailContent.Body body) {                message.mHtml = body.mHtmlContent;                message.mText = body.mTextContent;                message.mHtmlReply = null;                message.mTextReply = null;                message.mIntroText = null;                mSource = message;                mSourceAttachments = new ArrayList<EmailContent.Attachment>();                if (restoreViews) {                    //更新界面                    String subject = message.mSubject;                    mWriteSubject.setText(subject);                    mWriteBodyText.setText(message.mText);                    HcLog.D("mTo = " + message.mTo);                    displayQuotedText(message.mText, message.mHtml);                    setInitialComposeText(null, getAccountSignature(mAccount));                }                loadAttachments(message.mId, mAccount, new AttachmentLoadedCallback() {                    @Override                    public void onAttachmentLoaded(EmailContent.Attachment[] attachments) {                        final boolean supportsSmartForward =                                (mAccount.mFlags & Account.FLAGS_SUPPORTS_SMART_FORWARD) != 0;                        // Process the attachments to have the appropriate smart forward flags.                        for (EmailContent.Attachment attachment : attachments) {                            if (supportsSmartForward) {                                attachment.mFlags |= EmailContent.Attachment.FLAG_SMART_FORWARD;                            }                            mSourceAttachments.add(attachment);                        }                    }                });//                if (mAction.equals(ACTION_EDIT_DRAFT)) {//                    // Resuming a draft may in fact be resuming a reply/reply all/forward.//                    // Use a best guess and infer the action here.//                    String inferredAction = inferAction();//                    if (inferredAction != null) {//                        setAction(inferredAction);//                        // No need to update the action selector as switching actions should do it.//                        return;//                    }//                }            }            @Override            public void onLoadFailed() {                // The loading of the source message is only really required if it is needed                // immediately to restore the view contents. In the case of resuming draft, it                // is only needed to gather additional information.                if (restoreViews) {//                    Utility.showToast(MessageCompose.this, R.string.error_loading_message_body);                    finish();                }            }        }).executeSerial((Void[]) null);    }    @Override    public void onActivityResult(int requestCode, int resultCode, Intent data) {        // TODO Auto-generated method stub        if (resultCode == Activity.RESULT_OK) {            if (requestCode == HcChooseHomeView.REQUEST_CODE) {                ArrayList<ItemInfo> infos = data.getParcelableArrayListExtra(HcChooseHomeView.CLICK_KEY);                if (mToFlag) {                    StringBuilder sb = new StringBuilder();                    for (int i = 0; i < infos.size(); i++) {                        String info = infos.get(i).getItemValue();                        if (!mInfo.contains(info)) {                            mInfo.add(info);                        }                    }                    for (String info : mInfo) {                        if (!"".equals(info) && info != null) {                            sb.append(info);                            sb.append(",");                        }                    }                    mWriteTo.setText(sb.toString());                    mWriteTo.setSelection(mWriteTo.getText().length());                    mToFlag = false;                } else if (mCcFlag) {                    StringBuilder sb = new StringBuilder();                    for (int i = 0; i < infos.size(); i++) {                        String info = infos.get(i).getItemValue();                        if (!mAddInfo.contains(info)) {                            mAddInfo.add(info);                        }                    }                    for (String info : mAddInfo) {                        if (!"".equals(info) && info != null) {                            sb.append(info);                            sb.append(",");                        }                    }                    mWriteCc.setText(sb.toString());                    mWriteCc.setSelection(mWriteCc.getText().length());                    mCcFlag = false;                }            } else if (requestCode == HcUtil.REQUEST_CODE_FROM_CAMERA) {                if (data != null && data.getExtras() != null) {                    ImageItemInfo info = data.getParcelableExtra("image");                    if (info != null) {                        addItem(info);                    } else {                        ArrayList<ImageItemInfo> infos = data.getParcelableArrayListExtra("images");                        if (infos != null) {                            HcmailAtta itemInfo;                            for (ImageItemInfo imageItemInfo : infos) {                                itemInfo = new HcmailAtta();                                String name = imageItemInfo.getFileName();                                if (!"".equals(name) && name != null) {                                    itemInfo.setAttaName(name + ".jpg");                                } else {                                    String path = imageItemInfo.getImagePath();                                    itemInfo.setAttaName(path.substring(path.lastIndexOf("/") + 1, path.length()));                                }                                HcLog.D("imageItemInfo.getImagePath() = " + imageItemInfo.getImagePath());                                itemInfo.setAttaId("file://" + imageItemInfo.getImagePath());                                itemInfo.setSelected(true);                                mImages.add(itemInfo);                            }                            if (mAdapter != null)                                if (mImages.size() > 0) {                                    for (ImageItemInfo infor : infos) {//                                        String filename = infor.getFileName();//                                        String path = "content://media/external/images/media/" + 286550;                                        String path = infor.getImagePath();                                        if (!"".equals(path) && path != null) {                                            Uri uri = Uri.parse(path);                                            HcLog.D("uri =" + uri);                                            HcLog.D("getUri(uri) =" + getUri(uri));                                            addAttachment(loadAttachmentInfo(getUri(uri)));                                        }                                    }//                                    mSourceAttachments.add(mImages)                                    mLine.setVisibility(View.VISIBLE);                                    mAdapter.notifyDataSetChanged();                                } else {                                    mLine.setVisibility(View.GONE);                                }                        }                    }                }            }        }    }    private void addItem(ImageItemInfo info) {        HcmailAtta itemInfo = new HcmailAtta();        String name = info.getFileName();        if (!"".equals(name) && name != null) {            itemInfo.setAttaName(name + ".jpg");        } else {            String path = info.getImagePath();            itemInfo.setAttaName(path.substring(path.lastIndexOf("/") + 1, path.length()));        }        itemInfo.setAttaId("file://" + info.getImagePath());        itemInfo.setSelected(true);        mImages.add(itemInfo);        if (mAdapter != null) {            if (mImages.size() > 0) {//                String filename = info.getFileName();//                String path = "content://media/external/images/media/" + filename;                String path = info.getImagePath();                Uri uri = Uri.parse(path);                HcLog.D("getUri(uri) =" + getUri(uri));                addAttachment(loadAttachmentInfo(getUri(uri)));                mLine.setVisibility(View.VISIBLE);                mAdapter.notifyDataSetChanged();            } else {                mLine.setVisibility(View.GONE);            }        }    }    private EmailContent.Attachment loadAttachmentInfo(Uri uri) {        long size = -1;        ContentResolver contentResolver = getContentResolver();        // Load name & size independently, because not all providers support both        final String name = Utility.getContentFileName(this, uri);        Cursor metadataCursor = contentResolver.query(uri, ATTACHMENT_META_SIZE_PROJECTION,                null, null, null);        if (metadataCursor != null) {            try {                if (metadataCursor.moveToFirst()) {                    size = metadataCursor.getLong(ATTACHMENT_META_SIZE_COLUMN_SIZE);                }            } finally {                metadataCursor.close();            }        }        // When the size is not provided, we need to determine it locally.        if (size < 0) {            // if the URI is a file: URI, ask file system for its size            if ("file".equalsIgnoreCase(uri.getScheme())) {                String path = uri.getPath();                if (path != null) {                    File file = new File(path);                    size = file.length();  // Returns 0 for file not found                }            }            if (size <= 0) {                // The size was not measurable;  This attachment is not safe to use.                // Quick hack to force a relevant error into the UI                // TODO: A proper announcement of the problem                size = AttachmentUtilities.MAX_ATTACHMENT_UPLOAD_SIZE + 1;            }        }        EmailContent.Attachment attachment = new EmailContent.Attachment();        attachment.mFileName = name;        attachment.mContentUri = uri.toString();        attachment.mSize = size;        attachment.mMimeType = AttachmentUtilities.inferMimeTypeForUri(this, uri);        return attachment;    }    /**     * Displays quoted text from the original email     */    private void displayQuotedText(String textBody, String htmlBody) {        // Only use plain text if there is no HTML body        boolean plainTextFlag = TextUtils.isEmpty(htmlBody);        String text = plainTextFlag ? textBody : htmlBody;        if (text != null) {            text = plainTextFlag ? EmailHtmlUtil.escapeCharacterToDisplay(text) : text;            // TODO: re-enable EmailHtmlUtil.resolveInlineImage() for HTML            //    EmailHtmlUtil.resolveInlineImage(getContentResolver(), mAccount,            //                                     text, message, 0);            if (mWriteWeb != null) {                mWriteWeb.loadDataWithBaseURL("email://", text, "text/html", "utf-8", null);            }        }    }    private Uri getUri(Uri uri) {        String path = uri.getEncodedPath();        if (path != null) {            path = Uri.decode(path);            ContentResolver cr = this.getContentResolver();            StringBuffer buff = new StringBuffer();            buff.append("(")                    .append(MediaStore.Images.ImageColumns.DATA)                    .append("=")                    .append("'" + path + "'")                    .append(")");            Cursor cur = cr.query(                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,                    new String[]{MediaStore.Images.ImageColumns._ID},                    buff.toString(), null, null);            int index = 0;            for (cur.moveToFirst(); !cur.isAfterLast(); cur                    .moveToNext()) {                index = cur.getColumnIndex(MediaStore.Images.ImageColumns._ID);                // set _id value                index = cur.getInt(index);            }            if (index == 0) {                //do nothing            } else {                Uri uri_temp = Uri                        .parse("content://media/external/images/media/"                                + index);                if (uri_temp != null) {                    uri = uri_temp;                }            }        }        return uri;    }    /**     * 返回键处理     */    @Override    public boolean onKey(View v, int keyCode, KeyEvent event) {        if (keyCode == KeyEvent.KEYCODE_DEL                && event.getAction() == KeyEvent.ACTION_DOWN) {            if (mWriteTo.isFocused()) {                mDeleToFlag = true;            } else if (mWriteCc.isFocused()) {                mDeleCcFlag = true;            }            if (mDeleToFlag) {                onKeyClick(mWriteTo, mInfo);                mDeleToFlag = false;            } else if (mDeleCcFlag) {                onKeyClick(mWriteCc, mAddInfo);                mDeleCcFlag = false;            }        }        return false;    }    private void onKeyClick(MultiAutoCompleteTextView mEdit, ArrayList<String> mInfoStr) {        int selection = mEdit.getSelectionStart();        String text = mEdit.getText().toString();        if (selection > 0) {            String deleteStr = text.substring(0, selection);            String startStr = text.substring(0, selection - 1);            String textChar = deleteStr.substring(selection - 1);            String write = mEdit.getText().toString().trim();            String secondText = write.substring(selection, write.length());            //如果截取到的光标最后一位为","            if (",".equals(textChar)) {                int start = startStr.lastIndexOf(",");                int end = selection;                String info = write.substring(start + 1, end - 1);                if (mInfoStr.contains(info)) {                    mInfoStr.remove(info);                }                mEdit.getText().delete(start + 2, end);            } else if (startStr.indexOf(",") != -1 && secondText.indexOf(",") != -1) {                int start = startStr.lastIndexOf(",");                int mend = write.length();                String second = write.substring(start + 1, mend);                int end = second.indexOf(",") + start;                String info = write.substring(start + 1, end + 1);                if (mInfoStr.contains(info)) {                    mInfoStr.remove(info);                }                mEdit.getText().delete(start + 2, end + 2);            } else if (secondText.indexOf(",") != -1 && startStr.indexOf(",") == -1) {                int end = secondText.indexOf(",") + selection;                String info = write.substring(0, end);                if (mInfoStr.contains(info)) {                    mInfoStr.remove(info);                }                mEdit.getText().delete(0, end + 1);            }        }    }    /**     * Removes an attachment from the current message.     * If the attachment has previous been saved in the db (i.e. this is a draft message which     * has previously been saved), then the draft is deleted from the db.     * <p>     * This does not update the UI to remove the attachment view.     *     * @param attachments the list of attachments to delete from. Injected for tests.     * @param attachment  the attachment to delete     */    private void deleteAttachment(List<EmailContent.Attachment> attachments, EmailContent.Attachment attachment) {        HcLog.D("attachments1 = " + attachment);        attachments.remove(attachment);        HcLog.D("attachmentss = " + attachment);        //草稿箱中删除附件时        if (attachment.isSaved() && (attachment.mMessageKey == mDraft.mId)) {            final long attachmentId = attachment.mId;            HcLog.D("attachmentId = " + attachmentId);            EmailAsyncTask.runAsyncParallel(new Runnable() {                @Override                public void run() {                    mController.deleteAttachment(attachmentId);                }            });        }    }}